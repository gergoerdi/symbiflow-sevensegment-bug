/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.4.3. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  CLK // clock
    , input [7:0] SWITCHES

      // Outputs
    , output wire [3:0] SS_AN
    , output wire [6:0] SS_SEG
    , output wire  SS_DP
    );
  wire  c$bindCsr;
  wire  c$s1_case_scrut;
  reg [16:0] s1 = 17'd0;
  wire [16:0] c$s1_app_arg;
  wire [1:0] c$i_app_arg;
  wire [3:0] c$app_arg;
  reg [3:0] c$app_arg_0;
  wire signed [63:0] wild;
  wire signed [63:0] c$wild_app_arg;
  wire [3:0] result;
  wire [5:0] result_0;
  reg [1:0] i = 2'd0;
  wire signed [63:0] c$wild_app_arg_0;
  wire [4:0] c$app_arg_1;
  wire [8:0] result_1;
  wire signed [63:0] wild_0;
  reg [6:0] c$ds1_app_arg;
  wire [3:0] c$app_arg_2;
  wire [6:0] c$app_arg_3;
  wire [0:0] c$app_arg_4;
  wire [7:0] ds1;
  wire [3:0] x;
  wire [9:0] ds1_0;
  wire [7:0] c$ds1_app_arg_0;
  wire [7:0] c$ds1_app_arg_1;
  wire [3:0] c$vec;
  wire  c$din;
  wire [1:0] c$i_11;
  wire [19:0] c$vecFlat;
  wire [3:0] c$vec_0;
  wire [6:0] c$vec_1;
  wire [4:0] ds1_selection_1;
  wire [7:0] c$vec_2;
  wire [11:0] SS;

  // resetGen on
  // pragma translate_off

  reg  rst;
  localparam reset_period = 30001 + ((1 - 1) * 100000);
  initial begin
    #1     rst =  1 ;
    #reset_period rst =  0 ;
  end
  assign c$bindCsr = rst;
  // pragma translate_on
  // resetGen end

  assign c$s1_case_scrut = s1 == 17'd99999;

  // register begin
  always @(posedge CLK or  posedge  c$bindCsr) begin : s1_register
    if ( c$bindCsr) begin
      s1 <= 17'd0;
    end else begin
      s1 <= c$s1_app_arg;
    end
  end
  // register end

  assign c$s1_app_arg = c$s1_case_scrut ? 17'd0 : (s1 + 17'd1);

  assign c$i_app_arg = (i == 2'd3) ? 2'd0 : (i + 2'd1);

  assign c$vec = (((c$app_arg_0)));

  // map begin
  genvar i_0;
  generate
  for (i_0=0; i_0 < 4; i_0 = i_0 + 1) begin : map
    wire [0:0] map_in;
    assign map_in = c$vec[i_0*1+:1];
    wire  map_out;
    assign map_out = map_in == 1'b1;


    assign c$app_arg[i_0*1+:1] = map_out;
  end
  endgenerate
  // map end

  assign c$din = (1'b1);

  // replaceBit start
  always @(*) begin
    c$app_arg_0 = 4'b0000;
    c$app_arg_0[(wild)] = c$din;
  end
  // replaceBit end

  assign wild = $signed(c$wild_app_arg);

  assign c$wild_app_arg = $unsigned({{(64-2) {1'b0}},i});

  // reverse begin
  genvar i_1;
  generate
  for (i_1 = 0; i_1 < 4; i_1 = i_1 + 1) begin : reverse
    assign result[(4 - 1 - i_1)*1+:1] = c$app_arg[i_1*1+:1];
  end
  endgenerate
  // reverse end

  assign result_0 = {result,   i};

  // register begin
  always @(posedge CLK or  posedge  c$bindCsr) begin : i_register
    if ( c$bindCsr) begin
      i <= 2'd0;
    end else if (c$s1_case_scrut) begin
      i <= c$i_app_arg;
    end
  end
  // register end

  assign c$i_11 = result_0[1:0];

  assign c$wild_app_arg_0 = $unsigned({{(64-2) {1'b0}},c$i_11});

  assign c$vecFlat = ({({2 {{1'b0,4'bxxxx}}}),ds1_0});

  // index begin
  wire [4:0] vecArray [0:4-1];
  genvar i_2;
  generate
  for (i_2=0; i_2 < 4; i_2=i_2+1) begin : mk_array
    assign vecArray[(4-1)-i_2] = c$vecFlat[i_2*5+:5];
  end
  endgenerate
  assign c$app_arg_1 = vecArray[(wild_0)];
  // index end

  assign result_1 = {result_0[5:2],
                     c$app_arg_1};

  assign wild_0 = $signed(c$wild_app_arg_0);

  always @(*) begin
    case(x)
      4'd0 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                              1'b1,   1'b1,   1'b1,   1'b0};
      4'd1 : c$ds1_app_arg = {1'b0,   1'b1,   1'b1,
                              1'b0,   1'b0,   1'b0,   1'b0};
      4'd2 : c$ds1_app_arg = {1'b1,   1'b1,   1'b0,
                              1'b1,   1'b1,   1'b0,   1'b1};
      4'd3 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                              1'b1,   1'b0,   1'b0,   1'b1};
      4'd4 : c$ds1_app_arg = {1'b0,   1'b1,   1'b1,
                              1'b0,   1'b0,   1'b1,   1'b1};
      4'd5 : c$ds1_app_arg = {1'b1,   1'b0,   1'b1,
                              1'b1,   1'b0,   1'b1,   1'b1};
      4'd6 : c$ds1_app_arg = {1'b1,   1'b0,   1'b1,
                              1'b1,   1'b1,   1'b1,   1'b1};
      4'd7 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                              1'b0,   1'b0,   1'b0,   1'b0};
      4'd8 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                              1'b1,   1'b1,   1'b1,   1'b1};
      4'd9 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                              1'b1,   1'b0,   1'b1,   1'b1};
      4'd10 : c$ds1_app_arg = {1'b1,   1'b1,   1'b1,
                               1'b0,   1'b1,   1'b1,   1'b1};
      4'd11 : c$ds1_app_arg = {1'b0,   1'b0,   1'b1,
                               1'b1,   1'b1,   1'b1,   1'b1};
      4'd12 : c$ds1_app_arg = {1'b1,   1'b0,   1'b0,
                               1'b1,   1'b1,   1'b1,   1'b0};
      4'd13 : c$ds1_app_arg = {1'b0,   1'b1,   1'b1,
                               1'b1,   1'b1,   1'b0,   1'b1};
      4'd14 : c$ds1_app_arg = {1'b1,   1'b0,   1'b0,
                               1'b1,   1'b1,   1'b1,   1'b1};
      4'd15 : c$ds1_app_arg = {1'b1,   1'b0,   1'b0,
                               1'b0,   1'b1,   1'b1,   1'b1};
      default : c$ds1_app_arg = {7 {1'bx}};
    endcase
  end

  assign c$vec_0 = result_1[8:5];

  // map begin
  genvar i_3;
  generate
  for (i_3=0; i_3 < 4; i_3 = i_3 + 1) begin : map_0
    wire  map_in_0;
    assign map_in_0 = c$vec_0[i_3*1+:1];
    wire  map_out_0;
    wire [0:0] c$app_arg_5;
    wire  result_2;
    assign map_out_0 = result_2;

    assign c$app_arg_5 = map_in_0 ? 1'b1 : 1'b0;

    assign result_2 = ~ (c$app_arg_5);


    assign c$app_arg_2[i_3*1+:1] = map_out_0;
  end
  endgenerate
  // map end

  assign c$vec_1 = ds1[7:1];

  // map begin
  genvar i_4;
  generate
  for (i_4=0; i_4 < 7; i_4 = i_4 + 1) begin : map_1
    wire  map_in_1;
    assign map_in_1 = c$vec_1[i_4*1+:1];
    wire  map_out_1;
    wire [0:0] c$app_arg_6;
    wire  result_3;
    assign map_out_1 = result_3;

    assign c$app_arg_6 = map_in_1 ? 1'b1 : 1'b0;

    assign result_3 = ~ (c$app_arg_6);


    assign c$app_arg_3[i_4*1+:1] = map_out_1;
  end
  endgenerate
  // map end

  assign c$app_arg_4 = ds1[0:0] ? 1'b1 : 1'b0;

  assign SS = {c$app_arg_2,   c$app_arg_3,
               ~ (c$app_arg_4)};

  assign ds1_selection_1 = result_1[4:0];

  assign ds1 = ds1_selection_1[4:4] ? {c$ds1_app_arg,
                                       1'b0} : {{7 {1'b0}},   1'b0};

  assign x = result_1[3:0];

  // map begin
  genvar i_5;
  generate
  for (i_5=0; i_5 < 2; i_5 = i_5 + 1) begin : map_2
    wire [3:0] map_in_2;
    assign map_in_2 = c$ds1_app_arg_0[i_5*4+:4];
    wire [4:0] map_out_2;
    assign map_out_2 = {1'b1,map_in_2};


    assign ds1_0[i_5*5+:5] = map_out_2;
  end
  endgenerate
  // map end

  assign c$vec_2 = ((c$ds1_app_arg_1));

  // map begin
  genvar i_6;
  generate
  for (i_6=0; i_6 < 2; i_6 = i_6 + 1) begin : map_3
    wire [3:0] map_in_3;
    assign map_in_3 = c$vec_2[i_6*4+:4];
    wire [3:0] map_out_3;
    assign map_out_3 = map_in_3;


    assign c$ds1_app_arg_0[i_6*4+:4] = map_out_3;
  end
  endgenerate
  // map end

  // map begin
  genvar i_7;
  generate
  for (i_7=0; i_7 < 8; i_7 = i_7 + 1) begin : map_4
    wire  map_in_4;
    assign map_in_4 = SWITCHES[i_7*1+:1];
    wire [0:0] map_out_4;
    assign map_out_4 = map_in_4;


    assign c$ds1_app_arg_1[i_7*1+:1] = map_out_4;
  end
  endgenerate
  // map end

  assign SS_AN = SS[11:8];

  assign SS_SEG = SS[7:1];

  assign SS_DP = SS[0:0];


endmodule

